# 상속

## 상속 개념

+ 상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 코드의 중복을 줄여준다.
+ 부모 클래스의 수정으로 모든 자식 클래스들의 수정 효과를 가져오기 때문에 유지 보수 시간을 최소화 시켜준다.



## 클래스 상속

+ **현실에서 상속**은 부모가 자신을 선택해서 물려주지만, 프로그래밍에서는 자식이 부모를 선택한다.
+ 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지를 결정하고 extends 뒤에 부모 클래스 이름을 기술한다

#### 자바는 다중 상속을 허용하지 않는다.



## 부모 생성자 호출

+ 현실에서 부모 없는 자식이 있을 수 없듯이 자바에서도 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.

+ 모든 객체는 클래스의 생성자를 호출해야만 생성된다. 부모 객체도 예외는 아니다.
+ 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.
+ 명시적으로 선언되지 않았다면 컴파일러는 다음과 같은 기본 생성자를 생성해낸다.

#### 만약 매개값의 타입과 일치하는 부모 생성자가 없다면 -> 컴파일 오류가 발생한다.



#### 자식 클래스 내부에서 오버라이딩도니 부모 클래스의 메소드를 호출해야 하는 상황

-> 명시적으로 super 키워드를 붙여서 부모 메소드를 호출

super.부모메소드();



## 메소드 재정의 

+ 메소드 오버라이딩은 상속된 메소드의 내용이 자식 클래스에 맞지 않을 경우, 자식 클래스에서 동일한 메소드를 재정의하는 것을 말한다.
+ 메소드가 오버라이딩 되었다면 부모 객체의 메소드는 숨겨지기 때문에 자식 객체에서 메소드를 호출하면 오버라이딩된 자식 메소드가 호출된다.



### 메소드를 오버라이딩할 때 규칙

1. 부모의 메소드와 동일한 시그니처(리턴 타입, 메소드 이름, 매개 변수 리스트)를 가져야 한다.
2. 접근 제한을 더 강하게 오버라이딩 할 수 없다.
3. 새로운 예외를 throws 할 수 없다.



## final 클래스와 final 메소드

+ final 키워드는 클래스, 필드, 메소드 선언 시에 사용할 수 있다.
+ final 필드 -> 초기값 설정 후 더 이상 값을 변경할 수 없다.
+ final 클래스 -> 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다.
+ final 메소드 -> 오버라이딩 할 수 없는 메소드



## 타입 변환과 다형성

+ 다형성 : 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질
+ 다형성을 위해 자바는 부모 클래스로 타입 변환을 허용한다. 즉, 부모 타입에 모든 자식 객체가 대입될 수 있다.



## 자동 타입 변환

**부모 클래스 변수 = 자식 클래스 타입;**

+ 부모 타입으로 자동 타입 변환된 이후 -> 접근 가능한 맴버는 부모 클래스 맴버로만 한정된다.
+ 그러나 예외가 있는데, 오버라이딩된 메소드라면 자식 클래스의 메소드가 대신 호출된다.



## 매개 변수의 다형성

+ 매개 변수의 타입이 클래스일 경우, 해당 클래스의 객체 뿐만 아니라 자식 객체까지도 매개값으로 사용할 수 있다.



## 강제 타입 변환

자식클래스 변수 = (자식클래스)부모클래스타입;

+ **강제 타입 변환**은 부모 타입을 자식 타입으로 변환하는 것을 말한다.



## 객체 타입 확인

+ 어떤 객체가 어떤 클래스의 인스턴스인지 확인하려면 instanceof 연산자를 사용할 수 있다.

