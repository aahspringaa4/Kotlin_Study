# 3. 클래스 정적 맴버부터 Getter와 Setter까지

## 인스턴스 맴버와 this

this는 주로 (생성자, 메소드)의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 맴버임을 명시하고자 할 때 사용된다.

```
Car(String model)
{
		this.model = model;
}

void setModel(String)
{
		this.model = model;
}
```



## 정적 맴버와 static

+ 정적 맴버 : 클래스에 고정된 맴버
+ 정적 맴버는 객체에 소속된 맴버가 아니라 클래스에 소속된 맴버이기 때문에 클래스 맴버라고도 한다. 

```
public class 클래스
{
		// 정적 필드
		static 타입 필드;
		
		// 정적 메소드
		static 리턴타입 메소드(매개변수) {....}
}
```



### 필드 선언 시

인스턴스 필드로 선언할 것인가, 정적 필드로 선언할 것인가 판단기준



### 메소드 선언 시

인스턴스 메소드로 선언할 것인가, 정적 메소드로 선언할 것인가 판단기준



### 정적 맴버 사용

정적 맴버 사용시 클래스 뒤에 도트(.) 연산자로 접근

클래스.필드;

클래스.메소드();



### 정적 초기화 블록

정적 필드는 필드 선언과 동시에 초기값을 주는 것이 보통이다.

But) 블록 내부에 인스턴스 맴버 사용 불가능, this 키워드 사용 불가능

블록 내부에 인스턴스 맴버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야한다.



## 싱글톤

+ 가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다.
+ 단 하나만 생성되는 이 객체를 싱글톤이라고 한다.

```
public class 클래스
{
		private 클래스() {}
		
		private static 클래스 singleton = new 클래스();
		
		static 클래스 getInstance(){
				retuen signleton;
		}
}
```

+ 싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출 할 수 없도록 막아야한다. 생성자 앞에 접근 제어 지시자인 private를 붙여주면 된다.
+ 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다. 
+ 정적 필드도 private 접근 제한자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다.

+ 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언하여 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.
+ 외부에서 객체를 얻는 유일한 방법은 getInstance() 메소드를 호출



## final 필드

+ 초기값이 저장 -> 프로그램 실행 도중에 수정할 수 없다.

  final 필드의 초기값을 줄 수 있는 2가지 방법

  1. 필드 선언 시에 주는 방법 (단순값이라면 선언시에 주는 것이 제일 간단)
  2. 생성자에서 주는 방법 (복잡한 초기화 코드가 필요하거나 객체 생성시에 외부 데이터로 초기화해야 한다면 생성자에서 초기값을 지정해야한다.)
  3. + 생성자는 초기화 되지 않은 final 필드를 그대로 남겨두면 컴파일 에러가 발생한다.



## 상수

+ 불변의 값을 저장하는 필드

+ final 필드 != 상수
  + Why? : 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띄고 있으며 여러가지 값으로 초기화 될 수 없기 때문

**상수는 static이면서 final이어야 한다.**

static final 필드는 객체마다 저장되지 않고 클래스에만 포함된다 그리고 한번 초기값이 저장되면 변경할 수 없다.



## import문

#### 다른 패키지에 속하는 클래스를 사용하는 두가지 방법

1. 패키지와 클래스를 모두 기술

```
public class Car{
		com.kumho.Tire tire = new com.kumho.Tire();
}
```

2. import문 사용
   - import문이 작성되는 위치는 패키지 선언과 클래스 선언 시이다.
   - import com.kumho.Tire (상단에 추가)



## 접근 제한자

### public (모두 허용)

#### 적용대상

클래스, 필드, 생성자. 메소드 

#### 접근할 수 없는 클래스

없음



### private (모두 차단)

#### 적용대상

필드, 생성자, 메소드

#### 접근할 수 없는 클래스

모든 외부 클래스



### protected (일부 허용, 모두 차단)

#### 적용 대상

필드, 생성자, 메소드

#### 접근할 수 없는 클래스

자식 클래스가 아닌 다른 패키지에 소속된 클래스



### default (일부 허용, 일부 차단) 

#### 적용대상

클래스, 필드, 생성자, 메소드

#### 접근할 수 없는 클래스

다른 패키지에 소속된 클래스



## Getter와 Setter

+ 객체의 무결성이 깨지지 않도록 메소드를 통해 데이터를 변경하는 방법을 선호한다.

  ```
  private 타입 fieldname; 
  
  //Getter
  public 리턴타입 getFieldName(){
  		return fieldName
  }
  
  //Setter
  public void setFieldName(타입 fieldName){
  		this.fieldname = fieldname;
  }
  ```

+ 필드 접근 제한자 : private

  

+ 접근 제한자 : public

+ 리턴 타입: 필드 타입

+ 메소드 이름 : get + 필드 이름(첫문자 대문자)

+ 리턴값 : 필드값



+ 접근 제한자 : public 
+ 리턴 타입 : void
+ 메소드 이름 : set + 필드 이름(첫문자 대문자)
+ 매개 변수 타입 : 필드 타입