# 클래스 생성자부터 메소드까지

## 생성자

new 연산자와 같이 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

+ 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 기본생성자를 바이트 코드에 자동 추가 시킨다.

+ 클래스가 public이면 기본 생성자에도 public이 붙지만 클래스가 public 없이 선언되면 기본 생성자에도 public이 붙지 않는다.



## 생성자 선언

클래스 (매개 변수 선언)

{

​	//객체의 초기화 코드

}

관례적으로 매개변수는 필드와 동일한 이름을 갖도록 한다.

-> 생성자 내부에서 필드 접근 불가

-> this. 사용

-> this는 객체 자신의 참조인데, 자신을 " 나"라고 하듯이 객체가 객체 자신을 this라고 한다.



### 매개 변수 선언

생성자를 호출할 때 외부의 값을 생성자 블록 내부로 전달하는 역할



## 필드 초기화

+ 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.

+ 다른 값으로 초기화 하기 위한 2가지 방법
  + 필드를 선언할 때 초기값을 주는 방법
  + 생성자에서 초기값을 주는 방법



## 다른 생성자 호출

생성자에서 다른 생성자를 호출할 때 this() 코드를 사용한다.

클래스( [매개변수선언, ..] ){

​	this( 매개변수, ..., 값, ...);

​	실행문;

}

this() : 반드시 생성자의 첫줄에서만 허용된다.



## 메소드

+ 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.



+ 필드를 읽고 수정하는 역할
+ 다른 객체를 생성해서 다양한 기능을 수행
+ 객체 간의 데이터 전달의 수단



### 선언

```
리턴타입 메소드이름( [매개변수선언, ...]) {
	실행할 코드를 작성
}
```



### 리턴 타입

+ 리턴값이 있느냐 없느냐에 따라 메소드를 호출하는 방법이 조금 다르다.

  ​	ex) run(); <= 리턴 값이 없는 경우

  ​		   int s = sum(10, 20); <= 리턴 값이 있는 경우

+ 리턴 타입이 있다고 해서 반드시 리턴값을 변수에 저장할 필요는 없다.

+ 리턴값이 중요하지 않고 메소드 실행이 중요할 경우 변수 선언 없이 메소드를 호출할수 도 있다.

  ex) sum(10, 20);



### 작성 규칙

+ 숫자로 시작하면 안 되고, $와_를 제외한 특수 문자 사용 불가
+ 관례적으로 메소드명은 소문자로 작성한다.
+ 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 대문자로 작성한다.



### 매개 변수의 수를 모를 경우 1

+ 경우에 따라서 메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다.

+ 해결책 -> 배열 타입으로 선언

  + int sum(int[] a) {}

+ 배열의 항목 수는 호출할 때 결정된다

  + Int x = sum(new int[] { 1, 2, 3 });

+ 매개 변수를 배열 타입으로 선언하면,  메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.

  ​	-> 배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다.



### 매개 변수의 수를 모를 경우 2

+ 값의 리스트만 넘겨주는 방법
  + 메소드의 매개 변수를 ...를 사용하여 선언
  + 메소드 호출시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.



## 메소드 호출

### 클래스 내부에서 호출

+ 단순한 메소드 이름으로 호출

### 클래스 외부에서 호출

+ 우선 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용해 메소드 호출



## 메소드 오버로딩

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것

+ 조건 : 매개변수의 타입, 개수, 순서 중 하나가 달라야 한다.

+ 오버로딩된 메소드를 호출할 경우 -> JVM은 매개값의 타입을 보고 메소드를 선택한다.